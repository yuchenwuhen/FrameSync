// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PBBattle.proto

#ifndef PROTOBUF_PBBattle_2eproto__INCLUDED
#define PROTOBUF_PBBattle_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace PBBattle {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PBBattle_2eproto();
void protobuf_AssignDesc_PBBattle_2eproto();
void protobuf_ShutdownFile_PBBattle_2eproto();

class BattleUserInfo;
class TcpEnterBattle;
class UdpBattleReady;
class UdpBattleStart;
class PlayerOperation;
class UdpUpPlayerOperations;
class AllPlayerOperation;
class UdpDownFrameOperations;
class UdpUpDeltaFrames;
class UdpDownDeltaFrames;
class UdpUpGameOver;
class UdpDownGameOver;

enum RightOpType {
  noop = 0,
  rop1 = 1,
  rop2 = 2,
  rop3 = 3,
  rop4 = 4,
  rop5 = 5,
  rop6 = 6,
  rop7 = 7
};
bool RightOpType_IsValid(int value);
const RightOpType RightOpType_MIN = noop;
const RightOpType RightOpType_MAX = rop7;
const int RightOpType_ARRAYSIZE = RightOpType_MAX + 1;

// ===================================================================

class BattleUserInfo : public ::google::protobuf::MessageLite {
 public:
  BattleUserInfo();
  virtual ~BattleUserInfo();

  BattleUserInfo(const BattleUserInfo& from);

  inline BattleUserInfo& operator=(const BattleUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BattleUserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleUserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleUserInfo* other);

  // implements Message ----------------------------------------------

  BattleUserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleUserInfo& from);
  void MergeFrom(const BattleUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // required int32 battleID = 2;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIDFieldNumber = 2;
  inline ::google::protobuf::int32 battleid() const;
  inline void set_battleid(::google::protobuf::int32 value);

  // required int32 roleID = 3;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIDFieldNumber = 3;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBBattle.BattleUserInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_battleid();
  inline void clear_has_battleid();
  inline void set_has_roleid();
  inline void clear_has_roleid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 battleid_;
  ::google::protobuf::int32 roleid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static BattleUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class TcpEnterBattle : public ::google::protobuf::MessageLite {
 public:
  TcpEnterBattle();
  virtual ~TcpEnterBattle();

  TcpEnterBattle(const TcpEnterBattle& from);

  inline TcpEnterBattle& operator=(const TcpEnterBattle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TcpEnterBattle& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TcpEnterBattle* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TcpEnterBattle* other);

  // implements Message ----------------------------------------------

  TcpEnterBattle* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TcpEnterBattle& from);
  void MergeFrom(const TcpEnterBattle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 randSeed = 1;
  inline bool has_randseed() const;
  inline void clear_randseed();
  static const int kRandSeedFieldNumber = 1;
  inline ::google::protobuf::int32 randseed() const;
  inline void set_randseed(::google::protobuf::int32 value);

  // repeated .PBBattle.BattleUserInfo battleUserInfo = 2;
  inline int battleuserinfo_size() const;
  inline void clear_battleuserinfo();
  static const int kBattleUserInfoFieldNumber = 2;
  inline const ::PBBattle::BattleUserInfo& battleuserinfo(int index) const;
  inline ::PBBattle::BattleUserInfo* mutable_battleuserinfo(int index);
  inline ::PBBattle::BattleUserInfo* add_battleuserinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::PBBattle::BattleUserInfo >&
      battleuserinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBBattle::BattleUserInfo >*
      mutable_battleuserinfo();

  // @@protoc_insertion_point(class_scope:PBBattle.TcpEnterBattle)
 private:
  inline void set_has_randseed();
  inline void clear_has_randseed();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PBBattle::BattleUserInfo > battleuserinfo_;
  ::google::protobuf::int32 randseed_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static TcpEnterBattle* default_instance_;
};
// -------------------------------------------------------------------

class UdpBattleReady : public ::google::protobuf::MessageLite {
 public:
  UdpBattleReady();
  virtual ~UdpBattleReady();

  UdpBattleReady(const UdpBattleReady& from);

  inline UdpBattleReady& operator=(const UdpBattleReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UdpBattleReady& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UdpBattleReady* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UdpBattleReady* other);

  // implements Message ----------------------------------------------

  UdpBattleReady* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UdpBattleReady& from);
  void MergeFrom(const UdpBattleReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // required int32 battleID = 2;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIDFieldNumber = 2;
  inline ::google::protobuf::int32 battleid() const;
  inline void set_battleid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBBattle.UdpBattleReady)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_battleid();
  inline void clear_has_battleid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 battleid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static UdpBattleReady* default_instance_;
};
// -------------------------------------------------------------------

class UdpBattleStart : public ::google::protobuf::MessageLite {
 public:
  UdpBattleStart();
  virtual ~UdpBattleStart();

  UdpBattleStart(const UdpBattleStart& from);

  inline UdpBattleStart& operator=(const UdpBattleStart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UdpBattleStart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UdpBattleStart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UdpBattleStart* other);

  // implements Message ----------------------------------------------

  UdpBattleStart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UdpBattleStart& from);
  void MergeFrom(const UdpBattleStart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PBBattle.UdpBattleStart)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static UdpBattleStart* default_instance_;
};
// -------------------------------------------------------------------

class PlayerOperation : public ::google::protobuf::MessageLite {
 public:
  PlayerOperation();
  virtual ~PlayerOperation();

  PlayerOperation(const PlayerOperation& from);

  inline PlayerOperation& operator=(const PlayerOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerOperation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerOperation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerOperation* other);

  // implements Message ----------------------------------------------

  PlayerOperation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerOperation& from);
  void MergeFrom(const PlayerOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 battleID = 1;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIDFieldNumber = 1;
  inline ::google::protobuf::int32 battleid() const;
  inline void set_battleid(::google::protobuf::int32 value);

  // required int32 move = 2;
  inline bool has_move() const;
  inline void clear_move();
  static const int kMoveFieldNumber = 2;
  inline ::google::protobuf::int32 move() const;
  inline void set_move(::google::protobuf::int32 value);

  // optional int32 operationID = 3;
  inline bool has_operationid() const;
  inline void clear_operationid();
  static const int kOperationIDFieldNumber = 3;
  inline ::google::protobuf::int32 operationid() const;
  inline void set_operationid(::google::protobuf::int32 value);

  // optional .PBBattle.RightOpType rightOperation = 4;
  inline bool has_rightoperation() const;
  inline void clear_rightoperation();
  static const int kRightOperationFieldNumber = 4;
  inline ::PBBattle::RightOpType rightoperation() const;
  inline void set_rightoperation(::PBBattle::RightOpType value);

  // optional int32 operationValue1 = 5;
  inline bool has_operationvalue1() const;
  inline void clear_operationvalue1();
  static const int kOperationValue1FieldNumber = 5;
  inline ::google::protobuf::int32 operationvalue1() const;
  inline void set_operationvalue1(::google::protobuf::int32 value);

  // optional int32 operationValue2 = 6;
  inline bool has_operationvalue2() const;
  inline void clear_operationvalue2();
  static const int kOperationValue2FieldNumber = 6;
  inline ::google::protobuf::int32 operationvalue2() const;
  inline void set_operationvalue2(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBBattle.PlayerOperation)
 private:
  inline void set_has_battleid();
  inline void clear_has_battleid();
  inline void set_has_move();
  inline void clear_has_move();
  inline void set_has_operationid();
  inline void clear_has_operationid();
  inline void set_has_rightoperation();
  inline void clear_has_rightoperation();
  inline void set_has_operationvalue1();
  inline void clear_has_operationvalue1();
  inline void set_has_operationvalue2();
  inline void clear_has_operationvalue2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 battleid_;
  ::google::protobuf::int32 move_;
  ::google::protobuf::int32 operationid_;
  int rightoperation_;
  ::google::protobuf::int32 operationvalue1_;
  ::google::protobuf::int32 operationvalue2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static PlayerOperation* default_instance_;
};
// -------------------------------------------------------------------

class UdpUpPlayerOperations : public ::google::protobuf::MessageLite {
 public:
  UdpUpPlayerOperations();
  virtual ~UdpUpPlayerOperations();

  UdpUpPlayerOperations(const UdpUpPlayerOperations& from);

  inline UdpUpPlayerOperations& operator=(const UdpUpPlayerOperations& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UdpUpPlayerOperations& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UdpUpPlayerOperations* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UdpUpPlayerOperations* other);

  // implements Message ----------------------------------------------

  UdpUpPlayerOperations* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UdpUpPlayerOperations& from);
  void MergeFrom(const UdpUpPlayerOperations& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mesID = 1;
  inline bool has_mesid() const;
  inline void clear_mesid();
  static const int kMesIDFieldNumber = 1;
  inline ::google::protobuf::int32 mesid() const;
  inline void set_mesid(::google::protobuf::int32 value);

  // required .PBBattle.PlayerOperation operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline const ::PBBattle::PlayerOperation& operation() const;
  inline ::PBBattle::PlayerOperation* mutable_operation();
  inline ::PBBattle::PlayerOperation* release_operation();
  inline void set_allocated_operation(::PBBattle::PlayerOperation* operation);

  // @@protoc_insertion_point(class_scope:PBBattle.UdpUpPlayerOperations)
 private:
  inline void set_has_mesid();
  inline void clear_has_mesid();
  inline void set_has_operation();
  inline void clear_has_operation();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::PBBattle::PlayerOperation* operation_;
  ::google::protobuf::int32 mesid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static UdpUpPlayerOperations* default_instance_;
};
// -------------------------------------------------------------------

class AllPlayerOperation : public ::google::protobuf::MessageLite {
 public:
  AllPlayerOperation();
  virtual ~AllPlayerOperation();

  AllPlayerOperation(const AllPlayerOperation& from);

  inline AllPlayerOperation& operator=(const AllPlayerOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AllPlayerOperation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AllPlayerOperation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AllPlayerOperation* other);

  // implements Message ----------------------------------------------

  AllPlayerOperation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AllPlayerOperation& from);
  void MergeFrom(const AllPlayerOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PBBattle.PlayerOperation operations = 1;
  inline int operations_size() const;
  inline void clear_operations();
  static const int kOperationsFieldNumber = 1;
  inline const ::PBBattle::PlayerOperation& operations(int index) const;
  inline ::PBBattle::PlayerOperation* mutable_operations(int index);
  inline ::PBBattle::PlayerOperation* add_operations();
  inline const ::google::protobuf::RepeatedPtrField< ::PBBattle::PlayerOperation >&
      operations() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBBattle::PlayerOperation >*
      mutable_operations();

  // @@protoc_insertion_point(class_scope:PBBattle.AllPlayerOperation)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PBBattle::PlayerOperation > operations_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static AllPlayerOperation* default_instance_;
};
// -------------------------------------------------------------------

class UdpDownFrameOperations : public ::google::protobuf::MessageLite {
 public:
  UdpDownFrameOperations();
  virtual ~UdpDownFrameOperations();

  UdpDownFrameOperations(const UdpDownFrameOperations& from);

  inline UdpDownFrameOperations& operator=(const UdpDownFrameOperations& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UdpDownFrameOperations& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UdpDownFrameOperations* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UdpDownFrameOperations* other);

  // implements Message ----------------------------------------------

  UdpDownFrameOperations* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UdpDownFrameOperations& from);
  void MergeFrom(const UdpDownFrameOperations& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 frameID = 1;
  inline bool has_frameid() const;
  inline void clear_frameid();
  static const int kFrameIDFieldNumber = 1;
  inline ::google::protobuf::int32 frameid() const;
  inline void set_frameid(::google::protobuf::int32 value);

  // required .PBBattle.AllPlayerOperation operations = 2;
  inline bool has_operations() const;
  inline void clear_operations();
  static const int kOperationsFieldNumber = 2;
  inline const ::PBBattle::AllPlayerOperation& operations() const;
  inline ::PBBattle::AllPlayerOperation* mutable_operations();
  inline ::PBBattle::AllPlayerOperation* release_operations();
  inline void set_allocated_operations(::PBBattle::AllPlayerOperation* operations);

  // @@protoc_insertion_point(class_scope:PBBattle.UdpDownFrameOperations)
 private:
  inline void set_has_frameid();
  inline void clear_has_frameid();
  inline void set_has_operations();
  inline void clear_has_operations();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::PBBattle::AllPlayerOperation* operations_;
  ::google::protobuf::int32 frameid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static UdpDownFrameOperations* default_instance_;
};
// -------------------------------------------------------------------

class UdpUpDeltaFrames : public ::google::protobuf::MessageLite {
 public:
  UdpUpDeltaFrames();
  virtual ~UdpUpDeltaFrames();

  UdpUpDeltaFrames(const UdpUpDeltaFrames& from);

  inline UdpUpDeltaFrames& operator=(const UdpUpDeltaFrames& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UdpUpDeltaFrames& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UdpUpDeltaFrames* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UdpUpDeltaFrames* other);

  // implements Message ----------------------------------------------

  UdpUpDeltaFrames* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UdpUpDeltaFrames& from);
  void MergeFrom(const UdpUpDeltaFrames& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 battleID = 1;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIDFieldNumber = 1;
  inline ::google::protobuf::int32 battleid() const;
  inline void set_battleid(::google::protobuf::int32 value);

  // repeated int32 frames = 2;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 2;
  inline ::google::protobuf::int32 frames(int index) const;
  inline void set_frames(int index, ::google::protobuf::int32 value);
  inline void add_frames(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      frames() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_frames();

  // @@protoc_insertion_point(class_scope:PBBattle.UdpUpDeltaFrames)
 private:
  inline void set_has_battleid();
  inline void clear_has_battleid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > frames_;
  ::google::protobuf::int32 battleid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static UdpUpDeltaFrames* default_instance_;
};
// -------------------------------------------------------------------

class UdpDownDeltaFrames : public ::google::protobuf::MessageLite {
 public:
  UdpDownDeltaFrames();
  virtual ~UdpDownDeltaFrames();

  UdpDownDeltaFrames(const UdpDownDeltaFrames& from);

  inline UdpDownDeltaFrames& operator=(const UdpDownDeltaFrames& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UdpDownDeltaFrames& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UdpDownDeltaFrames* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UdpDownDeltaFrames* other);

  // implements Message ----------------------------------------------

  UdpDownDeltaFrames* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UdpDownDeltaFrames& from);
  void MergeFrom(const UdpDownDeltaFrames& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PBBattle.UdpDownFrameOperations framesData = 1;
  inline int framesdata_size() const;
  inline void clear_framesdata();
  static const int kFramesDataFieldNumber = 1;
  inline const ::PBBattle::UdpDownFrameOperations& framesdata(int index) const;
  inline ::PBBattle::UdpDownFrameOperations* mutable_framesdata(int index);
  inline ::PBBattle::UdpDownFrameOperations* add_framesdata();
  inline const ::google::protobuf::RepeatedPtrField< ::PBBattle::UdpDownFrameOperations >&
      framesdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBBattle::UdpDownFrameOperations >*
      mutable_framesdata();

  // @@protoc_insertion_point(class_scope:PBBattle.UdpDownDeltaFrames)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PBBattle::UdpDownFrameOperations > framesdata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static UdpDownDeltaFrames* default_instance_;
};
// -------------------------------------------------------------------

class UdpUpGameOver : public ::google::protobuf::MessageLite {
 public:
  UdpUpGameOver();
  virtual ~UdpUpGameOver();

  UdpUpGameOver(const UdpUpGameOver& from);

  inline UdpUpGameOver& operator=(const UdpUpGameOver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UdpUpGameOver& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UdpUpGameOver* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UdpUpGameOver* other);

  // implements Message ----------------------------------------------

  UdpUpGameOver* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UdpUpGameOver& from);
  void MergeFrom(const UdpUpGameOver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 battleID = 1;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIDFieldNumber = 1;
  inline ::google::protobuf::int32 battleid() const;
  inline void set_battleid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBBattle.UdpUpGameOver)
 private:
  inline void set_has_battleid();
  inline void clear_has_battleid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 battleid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static UdpUpGameOver* default_instance_;
};
// -------------------------------------------------------------------

class UdpDownGameOver : public ::google::protobuf::MessageLite {
 public:
  UdpDownGameOver();
  virtual ~UdpDownGameOver();

  UdpDownGameOver(const UdpDownGameOver& from);

  inline UdpDownGameOver& operator=(const UdpDownGameOver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UdpDownGameOver& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UdpDownGameOver* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UdpDownGameOver* other);

  // implements Message ----------------------------------------------

  UdpDownGameOver* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UdpDownGameOver& from);
  void MergeFrom(const UdpDownGameOver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PBBattle.UdpDownGameOver)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PBBattle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PBBattle_2eproto();
  #endif
  friend void protobuf_AssignDesc_PBBattle_2eproto();
  friend void protobuf_ShutdownFile_PBBattle_2eproto();

  void InitAsDefaultInstance();
  static UdpDownGameOver* default_instance_;
};
// ===================================================================


// ===================================================================

// BattleUserInfo

// required int32 uid = 1;
inline bool BattleUserInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleUserInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleUserInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleUserInfo::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 BattleUserInfo::uid() const {
  // @@protoc_insertion_point(field_get:PBBattle.BattleUserInfo.uid)
  return uid_;
}
inline void BattleUserInfo::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.BattleUserInfo.uid)
}

// required int32 battleID = 2;
inline bool BattleUserInfo::has_battleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleUserInfo::set_has_battleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleUserInfo::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleUserInfo::clear_battleid() {
  battleid_ = 0;
  clear_has_battleid();
}
inline ::google::protobuf::int32 BattleUserInfo::battleid() const {
  // @@protoc_insertion_point(field_get:PBBattle.BattleUserInfo.battleID)
  return battleid_;
}
inline void BattleUserInfo::set_battleid(::google::protobuf::int32 value) {
  set_has_battleid();
  battleid_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.BattleUserInfo.battleID)
}

// required int32 roleID = 3;
inline bool BattleUserInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleUserInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleUserInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleUserInfo::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 BattleUserInfo::roleid() const {
  // @@protoc_insertion_point(field_get:PBBattle.BattleUserInfo.roleID)
  return roleid_;
}
inline void BattleUserInfo::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.BattleUserInfo.roleID)
}

// -------------------------------------------------------------------

// TcpEnterBattle

// required int32 randSeed = 1;
inline bool TcpEnterBattle::has_randseed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpEnterBattle::set_has_randseed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpEnterBattle::clear_has_randseed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpEnterBattle::clear_randseed() {
  randseed_ = 0;
  clear_has_randseed();
}
inline ::google::protobuf::int32 TcpEnterBattle::randseed() const {
  // @@protoc_insertion_point(field_get:PBBattle.TcpEnterBattle.randSeed)
  return randseed_;
}
inline void TcpEnterBattle::set_randseed(::google::protobuf::int32 value) {
  set_has_randseed();
  randseed_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.TcpEnterBattle.randSeed)
}

// repeated .PBBattle.BattleUserInfo battleUserInfo = 2;
inline int TcpEnterBattle::battleuserinfo_size() const {
  return battleuserinfo_.size();
}
inline void TcpEnterBattle::clear_battleuserinfo() {
  battleuserinfo_.Clear();
}
inline const ::PBBattle::BattleUserInfo& TcpEnterBattle::battleuserinfo(int index) const {
  // @@protoc_insertion_point(field_get:PBBattle.TcpEnterBattle.battleUserInfo)
  return battleuserinfo_.Get(index);
}
inline ::PBBattle::BattleUserInfo* TcpEnterBattle::mutable_battleuserinfo(int index) {
  // @@protoc_insertion_point(field_mutable:PBBattle.TcpEnterBattle.battleUserInfo)
  return battleuserinfo_.Mutable(index);
}
inline ::PBBattle::BattleUserInfo* TcpEnterBattle::add_battleuserinfo() {
  // @@protoc_insertion_point(field_add:PBBattle.TcpEnterBattle.battleUserInfo)
  return battleuserinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBBattle::BattleUserInfo >&
TcpEnterBattle::battleuserinfo() const {
  // @@protoc_insertion_point(field_list:PBBattle.TcpEnterBattle.battleUserInfo)
  return battleuserinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBBattle::BattleUserInfo >*
TcpEnterBattle::mutable_battleuserinfo() {
  // @@protoc_insertion_point(field_mutable_list:PBBattle.TcpEnterBattle.battleUserInfo)
  return &battleuserinfo_;
}

// -------------------------------------------------------------------

// UdpBattleReady

// required int32 uid = 1;
inline bool UdpBattleReady::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdpBattleReady::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdpBattleReady::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdpBattleReady::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 UdpBattleReady::uid() const {
  // @@protoc_insertion_point(field_get:PBBattle.UdpBattleReady.uid)
  return uid_;
}
inline void UdpBattleReady::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.UdpBattleReady.uid)
}

// required int32 battleID = 2;
inline bool UdpBattleReady::has_battleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UdpBattleReady::set_has_battleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UdpBattleReady::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UdpBattleReady::clear_battleid() {
  battleid_ = 0;
  clear_has_battleid();
}
inline ::google::protobuf::int32 UdpBattleReady::battleid() const {
  // @@protoc_insertion_point(field_get:PBBattle.UdpBattleReady.battleID)
  return battleid_;
}
inline void UdpBattleReady::set_battleid(::google::protobuf::int32 value) {
  set_has_battleid();
  battleid_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.UdpBattleReady.battleID)
}

// -------------------------------------------------------------------

// UdpBattleStart

// -------------------------------------------------------------------

// PlayerOperation

// required int32 battleID = 1;
inline bool PlayerOperation::has_battleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerOperation::set_has_battleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerOperation::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerOperation::clear_battleid() {
  battleid_ = 0;
  clear_has_battleid();
}
inline ::google::protobuf::int32 PlayerOperation::battleid() const {
  // @@protoc_insertion_point(field_get:PBBattle.PlayerOperation.battleID)
  return battleid_;
}
inline void PlayerOperation::set_battleid(::google::protobuf::int32 value) {
  set_has_battleid();
  battleid_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.PlayerOperation.battleID)
}

// required int32 move = 2;
inline bool PlayerOperation::has_move() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerOperation::set_has_move() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerOperation::clear_has_move() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerOperation::clear_move() {
  move_ = 0;
  clear_has_move();
}
inline ::google::protobuf::int32 PlayerOperation::move() const {
  // @@protoc_insertion_point(field_get:PBBattle.PlayerOperation.move)
  return move_;
}
inline void PlayerOperation::set_move(::google::protobuf::int32 value) {
  set_has_move();
  move_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.PlayerOperation.move)
}

// optional int32 operationID = 3;
inline bool PlayerOperation::has_operationid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerOperation::set_has_operationid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerOperation::clear_has_operationid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerOperation::clear_operationid() {
  operationid_ = 0;
  clear_has_operationid();
}
inline ::google::protobuf::int32 PlayerOperation::operationid() const {
  // @@protoc_insertion_point(field_get:PBBattle.PlayerOperation.operationID)
  return operationid_;
}
inline void PlayerOperation::set_operationid(::google::protobuf::int32 value) {
  set_has_operationid();
  operationid_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.PlayerOperation.operationID)
}

// optional .PBBattle.RightOpType rightOperation = 4;
inline bool PlayerOperation::has_rightoperation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerOperation::set_has_rightoperation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerOperation::clear_has_rightoperation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerOperation::clear_rightoperation() {
  rightoperation_ = 0;
  clear_has_rightoperation();
}
inline ::PBBattle::RightOpType PlayerOperation::rightoperation() const {
  // @@protoc_insertion_point(field_get:PBBattle.PlayerOperation.rightOperation)
  return static_cast< ::PBBattle::RightOpType >(rightoperation_);
}
inline void PlayerOperation::set_rightoperation(::PBBattle::RightOpType value) {
  assert(::PBBattle::RightOpType_IsValid(value));
  set_has_rightoperation();
  rightoperation_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.PlayerOperation.rightOperation)
}

// optional int32 operationValue1 = 5;
inline bool PlayerOperation::has_operationvalue1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerOperation::set_has_operationvalue1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerOperation::clear_has_operationvalue1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerOperation::clear_operationvalue1() {
  operationvalue1_ = 0;
  clear_has_operationvalue1();
}
inline ::google::protobuf::int32 PlayerOperation::operationvalue1() const {
  // @@protoc_insertion_point(field_get:PBBattle.PlayerOperation.operationValue1)
  return operationvalue1_;
}
inline void PlayerOperation::set_operationvalue1(::google::protobuf::int32 value) {
  set_has_operationvalue1();
  operationvalue1_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.PlayerOperation.operationValue1)
}

// optional int32 operationValue2 = 6;
inline bool PlayerOperation::has_operationvalue2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerOperation::set_has_operationvalue2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerOperation::clear_has_operationvalue2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerOperation::clear_operationvalue2() {
  operationvalue2_ = 0;
  clear_has_operationvalue2();
}
inline ::google::protobuf::int32 PlayerOperation::operationvalue2() const {
  // @@protoc_insertion_point(field_get:PBBattle.PlayerOperation.operationValue2)
  return operationvalue2_;
}
inline void PlayerOperation::set_operationvalue2(::google::protobuf::int32 value) {
  set_has_operationvalue2();
  operationvalue2_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.PlayerOperation.operationValue2)
}

// -------------------------------------------------------------------

// UdpUpPlayerOperations

// required int32 mesID = 1;
inline bool UdpUpPlayerOperations::has_mesid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdpUpPlayerOperations::set_has_mesid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdpUpPlayerOperations::clear_has_mesid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdpUpPlayerOperations::clear_mesid() {
  mesid_ = 0;
  clear_has_mesid();
}
inline ::google::protobuf::int32 UdpUpPlayerOperations::mesid() const {
  // @@protoc_insertion_point(field_get:PBBattle.UdpUpPlayerOperations.mesID)
  return mesid_;
}
inline void UdpUpPlayerOperations::set_mesid(::google::protobuf::int32 value) {
  set_has_mesid();
  mesid_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.UdpUpPlayerOperations.mesID)
}

// required .PBBattle.PlayerOperation operation = 2;
inline bool UdpUpPlayerOperations::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UdpUpPlayerOperations::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UdpUpPlayerOperations::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UdpUpPlayerOperations::clear_operation() {
  if (operation_ != NULL) operation_->::PBBattle::PlayerOperation::Clear();
  clear_has_operation();
}
inline const ::PBBattle::PlayerOperation& UdpUpPlayerOperations::operation() const {
  // @@protoc_insertion_point(field_get:PBBattle.UdpUpPlayerOperations.operation)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return operation_ != NULL ? *operation_ : *default_instance().operation_;
#else
  return operation_ != NULL ? *operation_ : *default_instance_->operation_;
#endif
}
inline ::PBBattle::PlayerOperation* UdpUpPlayerOperations::mutable_operation() {
  set_has_operation();
  if (operation_ == NULL) operation_ = new ::PBBattle::PlayerOperation;
  // @@protoc_insertion_point(field_mutable:PBBattle.UdpUpPlayerOperations.operation)
  return operation_;
}
inline ::PBBattle::PlayerOperation* UdpUpPlayerOperations::release_operation() {
  clear_has_operation();
  ::PBBattle::PlayerOperation* temp = operation_;
  operation_ = NULL;
  return temp;
}
inline void UdpUpPlayerOperations::set_allocated_operation(::PBBattle::PlayerOperation* operation) {
  delete operation_;
  operation_ = operation;
  if (operation) {
    set_has_operation();
  } else {
    clear_has_operation();
  }
  // @@protoc_insertion_point(field_set_allocated:PBBattle.UdpUpPlayerOperations.operation)
}

// -------------------------------------------------------------------

// AllPlayerOperation

// repeated .PBBattle.PlayerOperation operations = 1;
inline int AllPlayerOperation::operations_size() const {
  return operations_.size();
}
inline void AllPlayerOperation::clear_operations() {
  operations_.Clear();
}
inline const ::PBBattle::PlayerOperation& AllPlayerOperation::operations(int index) const {
  // @@protoc_insertion_point(field_get:PBBattle.AllPlayerOperation.operations)
  return operations_.Get(index);
}
inline ::PBBattle::PlayerOperation* AllPlayerOperation::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:PBBattle.AllPlayerOperation.operations)
  return operations_.Mutable(index);
}
inline ::PBBattle::PlayerOperation* AllPlayerOperation::add_operations() {
  // @@protoc_insertion_point(field_add:PBBattle.AllPlayerOperation.operations)
  return operations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBBattle::PlayerOperation >&
AllPlayerOperation::operations() const {
  // @@protoc_insertion_point(field_list:PBBattle.AllPlayerOperation.operations)
  return operations_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBBattle::PlayerOperation >*
AllPlayerOperation::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:PBBattle.AllPlayerOperation.operations)
  return &operations_;
}

// -------------------------------------------------------------------

// UdpDownFrameOperations

// required int32 frameID = 1;
inline bool UdpDownFrameOperations::has_frameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdpDownFrameOperations::set_has_frameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdpDownFrameOperations::clear_has_frameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdpDownFrameOperations::clear_frameid() {
  frameid_ = 0;
  clear_has_frameid();
}
inline ::google::protobuf::int32 UdpDownFrameOperations::frameid() const {
  // @@protoc_insertion_point(field_get:PBBattle.UdpDownFrameOperations.frameID)
  return frameid_;
}
inline void UdpDownFrameOperations::set_frameid(::google::protobuf::int32 value) {
  set_has_frameid();
  frameid_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.UdpDownFrameOperations.frameID)
}

// required .PBBattle.AllPlayerOperation operations = 2;
inline bool UdpDownFrameOperations::has_operations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UdpDownFrameOperations::set_has_operations() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UdpDownFrameOperations::clear_has_operations() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UdpDownFrameOperations::clear_operations() {
  if (operations_ != NULL) operations_->::PBBattle::AllPlayerOperation::Clear();
  clear_has_operations();
}
inline const ::PBBattle::AllPlayerOperation& UdpDownFrameOperations::operations() const {
  // @@protoc_insertion_point(field_get:PBBattle.UdpDownFrameOperations.operations)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return operations_ != NULL ? *operations_ : *default_instance().operations_;
#else
  return operations_ != NULL ? *operations_ : *default_instance_->operations_;
#endif
}
inline ::PBBattle::AllPlayerOperation* UdpDownFrameOperations::mutable_operations() {
  set_has_operations();
  if (operations_ == NULL) operations_ = new ::PBBattle::AllPlayerOperation;
  // @@protoc_insertion_point(field_mutable:PBBattle.UdpDownFrameOperations.operations)
  return operations_;
}
inline ::PBBattle::AllPlayerOperation* UdpDownFrameOperations::release_operations() {
  clear_has_operations();
  ::PBBattle::AllPlayerOperation* temp = operations_;
  operations_ = NULL;
  return temp;
}
inline void UdpDownFrameOperations::set_allocated_operations(::PBBattle::AllPlayerOperation* operations) {
  delete operations_;
  operations_ = operations;
  if (operations) {
    set_has_operations();
  } else {
    clear_has_operations();
  }
  // @@protoc_insertion_point(field_set_allocated:PBBattle.UdpDownFrameOperations.operations)
}

// -------------------------------------------------------------------

// UdpUpDeltaFrames

// required int32 battleID = 1;
inline bool UdpUpDeltaFrames::has_battleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdpUpDeltaFrames::set_has_battleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdpUpDeltaFrames::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdpUpDeltaFrames::clear_battleid() {
  battleid_ = 0;
  clear_has_battleid();
}
inline ::google::protobuf::int32 UdpUpDeltaFrames::battleid() const {
  // @@protoc_insertion_point(field_get:PBBattle.UdpUpDeltaFrames.battleID)
  return battleid_;
}
inline void UdpUpDeltaFrames::set_battleid(::google::protobuf::int32 value) {
  set_has_battleid();
  battleid_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.UdpUpDeltaFrames.battleID)
}

// repeated int32 frames = 2;
inline int UdpUpDeltaFrames::frames_size() const {
  return frames_.size();
}
inline void UdpUpDeltaFrames::clear_frames() {
  frames_.Clear();
}
inline ::google::protobuf::int32 UdpUpDeltaFrames::frames(int index) const {
  // @@protoc_insertion_point(field_get:PBBattle.UdpUpDeltaFrames.frames)
  return frames_.Get(index);
}
inline void UdpUpDeltaFrames::set_frames(int index, ::google::protobuf::int32 value) {
  frames_.Set(index, value);
  // @@protoc_insertion_point(field_set:PBBattle.UdpUpDeltaFrames.frames)
}
inline void UdpUpDeltaFrames::add_frames(::google::protobuf::int32 value) {
  frames_.Add(value);
  // @@protoc_insertion_point(field_add:PBBattle.UdpUpDeltaFrames.frames)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UdpUpDeltaFrames::frames() const {
  // @@protoc_insertion_point(field_list:PBBattle.UdpUpDeltaFrames.frames)
  return frames_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UdpUpDeltaFrames::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:PBBattle.UdpUpDeltaFrames.frames)
  return &frames_;
}

// -------------------------------------------------------------------

// UdpDownDeltaFrames

// repeated .PBBattle.UdpDownFrameOperations framesData = 1;
inline int UdpDownDeltaFrames::framesdata_size() const {
  return framesdata_.size();
}
inline void UdpDownDeltaFrames::clear_framesdata() {
  framesdata_.Clear();
}
inline const ::PBBattle::UdpDownFrameOperations& UdpDownDeltaFrames::framesdata(int index) const {
  // @@protoc_insertion_point(field_get:PBBattle.UdpDownDeltaFrames.framesData)
  return framesdata_.Get(index);
}
inline ::PBBattle::UdpDownFrameOperations* UdpDownDeltaFrames::mutable_framesdata(int index) {
  // @@protoc_insertion_point(field_mutable:PBBattle.UdpDownDeltaFrames.framesData)
  return framesdata_.Mutable(index);
}
inline ::PBBattle::UdpDownFrameOperations* UdpDownDeltaFrames::add_framesdata() {
  // @@protoc_insertion_point(field_add:PBBattle.UdpDownDeltaFrames.framesData)
  return framesdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBBattle::UdpDownFrameOperations >&
UdpDownDeltaFrames::framesdata() const {
  // @@protoc_insertion_point(field_list:PBBattle.UdpDownDeltaFrames.framesData)
  return framesdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBBattle::UdpDownFrameOperations >*
UdpDownDeltaFrames::mutable_framesdata() {
  // @@protoc_insertion_point(field_mutable_list:PBBattle.UdpDownDeltaFrames.framesData)
  return &framesdata_;
}

// -------------------------------------------------------------------

// UdpUpGameOver

// required int32 battleID = 1;
inline bool UdpUpGameOver::has_battleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdpUpGameOver::set_has_battleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdpUpGameOver::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdpUpGameOver::clear_battleid() {
  battleid_ = 0;
  clear_has_battleid();
}
inline ::google::protobuf::int32 UdpUpGameOver::battleid() const {
  // @@protoc_insertion_point(field_get:PBBattle.UdpUpGameOver.battleID)
  return battleid_;
}
inline void UdpUpGameOver::set_battleid(::google::protobuf::int32 value) {
  set_has_battleid();
  battleid_ = value;
  // @@protoc_insertion_point(field_set:PBBattle.UdpUpGameOver.battleID)
}

// -------------------------------------------------------------------

// UdpDownGameOver


// @@protoc_insertion_point(namespace_scope)

}  // namespace PBBattle

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PBBattle_2eproto__INCLUDED
